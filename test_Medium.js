// 2번째 문제
// 21 => 자리수가 짝수인 애들 중에서 22
// 자리수가 2 => n/2 = 2/2 = 1 앞에서 1번째의 곱과 뒤에서 1번째의 곱이 같은 가장 작은 수를 찾아라
// 3442 => 4자리수
// 4/2 = 2  => 3443

// 자리수가 짝수고, 앞뒤 곱한 값이 같은 숫자가 나오면 리턴해주면 되겠다

// 1<=n <= 50,000,000

// while? 런타임에러가 뜨진 않는데 정확도가 떨어지는 75

//
// 3번째 문제
// 지그재그 2차원행렬

// n, r , c => 5, 4, 3
// 5x5 지그재그 행렬에서 row = 4, col = 3
// 1  2  6  7  15
// 3  5  8  14 16
// 4  9  13 17 22
// 10 12 18 21 23
// 11 19 20 24 25

//! 1. index 값을 변화시키는 경우의 수
// 방향
// 오른쪽, 대각선 아래, 아래, 대각선 위
// 1. 방향이 왼쪽 아래일 때 direction = down
// 1-1. 왼쪽에 부딪힐 경우, 아래로 한칸 이동하고 방향 바꾸기
// : (x === 0) y + 1; direction = up
// 1-2. 왼쪽에 부딪히지 않을 경우,
// 1-2-1. 아래에 부딪힐 경우, 오른쪽으로 한칸 이동하고 방향 바꾸기
// 1-2-2. 아래에 부딪히지 않을 경우. 대각선 아래로 이동 (x-1, y+1)
// 2. 방향이 오른쪽 위 일 때
// 2-1. 오른쪽에 부딪힐 경우, 아래로 한 칸 이동 후 방향 바꾸기
// 2-2. 오른쪽에 부딪히지 않을 경우,
// 2-2-1. 맨 위에 부딪힐 경우, 오른쪽으로 한칸 이동 하고 방향 바꾸기
// 2-2-2. 맨 위에 부딪히지 않을 경우, 대각선 위로 이동(x+1, y-1)

//! 2. 필요한 변수들
// 1. 방향
// 2. x, y
// 3. 배열
// 4. 카운트 값
// 5. 총 반복의 횟수 5x5-1

//! 3. 구현
// 1. 변수 선언
// 2.

function zig(num, r, c) {
  let direction = "up";
  let size = num;
  let x = 0;
  let y = 0;
  let count = 1;
  // 배열 생성
  let arr = new Array(num).fill(1);
  for (let i in arr) {
    arr[i] = new Array(num).fill(1);
  }
  // 전체 반복 횟수
  let totalLeng = num * num - 1;

  // 반복
  for (let i = 0; i < totalLeng; i++) {
    // 0. 반복 시작할 때 마다 카운트++;
    count++;
    // 1. 방향이 대각선 위로 일 때
    if (direction === "up") {
      // 1-1. 오른쪽에 부딪힐 경우
      // 아래로 (x + 1)
      // 방향 전환
      // 삽입
      if (y === size - 1) {
        x = x + 1;
        direction = "down";
        arr[x][y] = count;
      }
      // 1-2. 오른쪽에 부딪히지 않을 경우
      else {
        // 1-2-1. 위쪽에 부딪힐 경우
        // 오른쪽 한 칸 (y + 1)
        // 방향 전환
        // 삽입
        if (x === 0) {
          y = y + 1;
          direction = "down";
          arr[x][y] = count;
        }
        // 1-2-2. 위쪽에 부딪히지 않을 경우
        // 대각선 위로 이동
        else {
          x = x - 1;
          y = y + 1;
          arr[x][y] = count;
        }
      }
    }
    // 2. 대각선 아래
    else {
      // if (direction === "down") {
      // 2-1. 왼쪽에 부딪힐 경우
      // 아래로 한칸 (x + 1)
      // 방향 전환
      // 삽입
      if (y === 0) {
        x = x + 1;
        direction = "up";
        arr[x][y] = count;
      }
      // 2-2. 왼쪽에 부딪히지 않을 경우.
      else {
        // 2-2-1. 아래에 부딪힐 경우
        // 오른쪽 한칸
        // 방향 전환
        if (x === size - 1) {
          y = y + 1;
          direction = "up";
          arr[x][y] = count;
        }
        // 2-2-2. 아래에 부딪히지 않을 경우
        // 대각선 아래 이동
        else {
          x = x + 1;
          y = y - 1;
          arr[x][y] = count;
        }
      }
    }
  }
  // console.log(arr);
  return arr[r - 1][c - 1];
}
